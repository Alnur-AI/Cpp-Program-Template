#include <iostream>
#include <cmath>


class Complex {
	double re, im;
public:
	// Конструкторы
	Complex(double a_re, double a_im)
		{ re = a_re ; im = a_im; }
	Complex()
		{re = 0; im = 0;}

	// Преобразователи
	Complex(int а) { re = a ; im = 0; }
	Complex(double а) { re = a ; im = 0; }

	// Получение свойств комплексного числа
	double modulo (){ return sqrt ( re * re + im * im ); };
	double argument() { return atan2(im, re ); };
	double get_re () { return re ; };
	double get_im () { return im; };

	// Операторы арифметические
	Complex operator + (Complex op2)
	{
		Complex res ( re + op2.re, im + op2.im );
		return res;
	}
	Complex operator - (Complex op2)
	{
		Complex res ( re - op2.re , im - op2.im );
		return res;
	}
	Complex operator * (Complex op2)
	{
		Complex res ( re * op2.re - im * op2.im , re * op2.im + im * op2.re );
		return res;
	}
	Complex operator / (Complex op2)
	{
		double dvs = op2.re * op2.re + op2.im * op2.im;
		Complex res ( ( re *op2.re + im * op2.im )/dvs ,
		(im *op2.re - re * op2.im ) / dvs ) ;
		return res ;
	}

};


int main()
{
	/* Ссылки

	int i ;// целочисленная переменная
	int *р = &i; // указатель на переменную i
	int &r = i ; // ссылка на переменную i


	i++;// увеличить i на 1
	(*р)++ ;// то же самое через указатель
	г++; // то же самое по ссылке`
	*/


	/*Ссылка, как тип возвращаемого значения


	Довольно интересные возможности открывает использование ссылоч­
ного типа как типа возвращаемого значения функции. Допустим, необ­
ходимо произвести поиск целочисленной переменной в составе слож­
ной структуры данных (например, искомая переменная является полем
структуры, которая, в свою очередь, является элементом массива и т. п.),
а затем либо использовать значение найденной переменной, либо выпол­
нить над ней то или иное присваивание. В такой ситуации поиск пере­
менной можно выделить в отдельную функцию, возвращающую ссылку
на найденную переменную. Если такая функция имеет профиль


int & find_var(param);

то допустимы будут, например, такие операторы:

int х = find_var ( param ) + 5;
find_var ( param ) = 3;
find_var ( param )*= 10;
find_var( param )++;
int у = ++find_var( param ) ;
	*/



/* константа

При описании адресных и ссылочных типов модификатор const поз­
воляет указать, что область памяти, на которую указывает/ссылается
описываемый объект, не подлежит изменению. Например:

const char * р ; // р указывает на неизменяемую область памяти
р = "A s t r i n g " ;// всё в порядке, переменная р может изменяться
*р = ’ а ’ ;// ОШИБКА! Нельзя менять область памяти,
						// на которую указывает р
р[5] = ’n’ ;// Это также ОШИБКА


Отметим ещё раз, что const char *р — это именно у к а з а т е л ь на кон­
с т а н т у , а не к о н с т а н т н ы й у к а з а т е л ь . Чтобы описать константу адрес­
ного типа, необходимо расположить ключевые слова в другом порядке:




char buf[20];
char * const p = buf + 5;
					// p - константа-указатель, указывающая на
					// шестой элемент массива buf (b u f[5])
р++; // ОШИБКА, значение р не может быть изменено
*р = ’ а ’ ; // Всё в порядке, изменяем значение b u f[5]
р[5] = ’Ь ’ ; // Всё в порядке, изменяем значение buf [5+5]



Аналогичным образом дело обстоит со ссылочными типами:

int i ;
const int &r = i ; // ссылка на константу
int x = r+5; // всё в порядке
i = 7;// тоже всё в порядке
г = 12; // ОШИБКА, значение по ссылке г нельзя менять

const int j = 5;
int &jr = j ; // ОШИБКА, нельзя ссылаться
							// на константу обычной ссылкой
const int &jcr = j ; // всё в порядке



Отметим, что константные ссылки позволяют передавать в функции
в качестве параметра адрес переменной вместо копирования значения,
при этом не позволяя эту переменную менять, как и при обычной пере­
даче по значению. Это может быть полезно, если параметр представляет
собой класс или структуру, размер которой существенно превышает раз­
мер адреса. Так, если в ранее описанном классе Complex вместо

Complex operator + (const Complex &op2)
{ return Complex(re+op2.re, im+op2.im); }


*/


/*Константные методы

class A
{
  int a;
  int b;
  public:
  int getA() const { return a; }
  int getB() const { return b; }
};



Но если вам вдруг понадобится делать прогу, в которой есть что-то вроде
подсчёта обращений к переменной, то семантика геттеров заставляет употребить
const, но счётчик обращений нужно увеличивать. Для этого случая есть слово mutable!
Этим словом мы пометим поля, которые вроде как бы члены класса, но они не отражают что ли его состояние


class A
{
  int a;
  int b;
  mutable int cntA;
  mutable int cntB;
  public:
  int getA() const { cntA++; return a; }
  int getB() const { cntB++; return b; }
};

*/

	Complex cmp;

	return 0;
}
